/******************************************************************************
 * Copyright 2017 The Apollo Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *****************************************************************************/

/**
 * @file
 * @brief Defines the LatController class.
 */

#pragma once

#include <fstream>
#include <memory>
#include <string>

#include "Eigen/Core"

#include "modules/common_msgs/config_msgs/vehicle_config.pb.h"
#include "modules/control/controllers/lat_based_lqr_controller/proto/lat_based_lqr_controller_conf.pb.h"

#include "cyber/plugin_manager/plugin_manager.h"
#include "modules/common/filters/digital_filter.h"
#include "modules/common/filters/digital_filter_coefficients.h"
#include "modules/common/filters/mean_filter.h"
#include "modules/control/control_component/controller_task_base/common/interpolation_1d.h"
#include "modules/control/control_component/controller_task_base/common/leadlag_controller.h"
#include "modules/control/control_component/controller_task_base/common/mrac_controller.h"
#include "modules/control/control_component/controller_task_base/common/trajectory_analyzer.h"
#include "modules/control/control_component/controller_task_base/control_task.h"

/**
 * @namespace apollo::control
 * @brief apollo::control
 */
namespace apollo {
namespace control {

/**
 * @class LatController
 *
 * @brief LQR-Based lateral controller, to compute steering target.
 * For more details, please refer to "Vehicle dynamics and control."
 * Rajamani, Rajesh. Springer Science & Business Media, 2011.
 */
class LatController : public ControlTask {
 public:
  /**
   * @brief constructor
   */
  LatController();

  /**
   * @brief destructor
   */
  virtual ~LatController();

  /**
   * @brief initialize Lateral Controller
   * @param control_conf control configurations
   * @return Status initialization status
   */
  common::Status Init(std::shared_ptr<DependencyInjector> injector) override;

  /**
   * @brief compute steering target based on current vehicle status
   *        and target trajectory
   * @param localization vehicle location
   * @param chassis vehicle status e.g., speed, acceleration
   * @param trajectory trajectory generated by planning
   * @param cmd control command
   * @return Status computation status
   */
  common::Status ComputeControlCommand(const localization::LocalizationEstimate *localization,
                                       const canbus::Chassis *chassis, 
                                       const planning::ADCTrajectory *trajectory,
                                       ControlCommand *cmd) override;

  /**
   * @brief reset Lateral Controller
   * @return Status reset status
   */
  common::Status Reset() override;

  /**
   * @brief stop Lateral controller
   */
  void Stop() override;

  /**
   * @brief Lateral controller name
   * @return string controller name in string
   */
  std::string Name() const override;

 protected:
  void UpdateState(SimpleLateralDebug *debug, const canbus::Chassis *chassis);

  // logic for reverse driving mode
  void UpdateDrivingOrientation();

  void UpdateMatrix();

  void UpdateMatrixCompound();

  double ComputeFeedForward(double ref_curvature) const;

  void ComputeLateralErrors(const double x, const double y, const double theta,
                            const double linear_v, const double angular_v, const double linear_a,
                            const TrajectoryAnalyzer &trajectory_analyzer,
                            SimpleLateralDebug *debug,
                            const canbus::Chassis *chassis);
  bool LoadControlConf();
  void InitializeFilters();
  void LoadLatGainScheduler();
  void LogInitParameters();
  void ProcessLogs(const SimpleLateralDebug *debug,
                   const canbus::Chassis *chassis);

  void CloseLogFile();

  // vehicle
  LatBaseLqrControllerConf lat_based_lqr_controller_conf_;

  // vehicle parameter
  common::VehicleParam vehicle_param_;

  // a proxy to analyze the planning trajectory
  TrajectoryAnalyzer trajectory_analyzer_;

  // the following parameters are vehicle physics related.
  // control time interval
  double ts_ = 0.0;
  // corner stiffness; front
  double cf_ = 0.0;
  // corner stiffness; rear
  double cr_ = 0.0;
  // distance between front and rear wheel center
  double wheelbase_ = 0.0;
  // mass of the vehicle
  double mass_ = 0.0;
  // distance from front wheel center to COM
  double lf_ = 0.0;
  // distance from rear wheel center to COM
  double lr_ = 0.0;
  // rotational inertia
  double iz_ = 0.0;
  // the ratio between the turn of the steering wheel and the turn of the wheels
  double steer_ratio_ = 0.0;
  // the maximum turn of steer
  double steer_single_direction_max_degree_ = 0.0;

  // limit steering to maximum theoretical lateral acceleration
  double max_lat_acc_ = 0.0;

  // number of control cycles look ahead (preview controller)
  int preview_window_ = 0;

  // longitudial length for look-ahead lateral error estimation during forward
  // driving and look-back lateral error estimation during backward driving
  // (look-ahead controller)
  double lookahead_station_low_speed_ = 0.0;    // 低速前进预瞄距离，针对D档
  double lookback_station_low_speed_ = 0.0;     // 低速倒车预瞄距离，针对R档
  double lookahead_station_high_speed_ = 0.0;   // 高速前进预瞄距离，针对D档
  double lookback_station_high_speed_ = 0.0;    // 高速倒车预瞄距离，针对R档

  // number of states without previews, includes
  // lateral error, lateral error rate, heading error, heading error rate
  const int basic_state_size_ = 4;
  // vehicle state matrix     车辆状态方程系数矩阵A x'=Ax+Bu+B1*Psi_des'  Psi_des‘期望的heading角变化率
  Eigen::MatrixXd matrix_a_;
  // vehicle state matrix (discrete-time)  A通过双线性变化法变成Ad
  Eigen::MatrixXd matrix_ad_;
  // vehicle state matrix compound; related to preview
  Eigen::MatrixXd matrix_adc_;
  // control matrix
  Eigen::MatrixXd matrix_b_;
  // control matrix (discrete-time)
  Eigen::MatrixXd matrix_bd_;
  // control matrix compound
  Eigen::MatrixXd matrix_bdc_;
  // gain matrix               状态反馈矩阵K   u=-kx  LQR求解出最优的K  K=[k0 k1 k2 k3] 1x4
  Eigen::MatrixXd matrix_k_;
  // control authority weighting matrix
  Eigen::MatrixXd matrix_r_;
  // state weighting matrix
  Eigen::MatrixXd matrix_q_;
  // updated state weighting matrix    如果打开增益调度表 那么要不同车速下可以配置不同的Q矩阵，所以要根据车速更新Q
  Eigen::MatrixXd matrix_q_updated_;
  // vehicle state matrix coefficients  车辆状态方程系数矩阵A中与v有关的时变项形如" 常数/v "，将常数提取出来放在矩阵matrix_a_coeff_里，每个周期处以v更新
  Eigen::MatrixXd matrix_a_coeff_;
  // 4 by 1 matrix; state matrix  [e1 e1' e2 e2'], e1,e2分别为横向误差，航向误差
  Eigen::MatrixXd matrix_state_;

  // parameters for lqr solver; number of iterations
  int lqr_max_iteration_ = 0;
  // parameters for lqr solver; threshold for computation
  double lqr_eps_ = 0.0;

  common::DigitalFilter digital_filter_;   //数字滤波器类对象，这里是用于对方向盘转角控制指令进行滤波

  std::unique_ptr<Interpolation1D> lat_err_interpolation_; //插值表类对象，这里是用于根据车速插值车辆的增益调度表，不同v下，车辆横向误差乘以不同比例

  std::unique_ptr<Interpolation1D> heading_err_interpolation_; //插值表类对象，这里是用于根据车速插值车辆的增益调度表，不同v下，车辆航向误差乘以不同比例

  // MeanFilter heading_rate_filter_;
  common::MeanFilter lateral_error_filter_; // 用来对反馈的横向误差进行均值滤波，简而言之就是移动窗口内的多个值取平均达到滤波的效果
  common::MeanFilter heading_error_filter_;

  // Lead/Lag controller        超前滞后控制器，在主回路上串联校正环节
  bool enable_leadlag_ = false;
  LeadlagController leadlag_controller_;

  // Mrac controller             模型参考自适应控制MRAC，这里没有开启
  bool enable_mrac_ = false;
  MracController mrac_controller_;

  // Look-ahead controller       预瞄控制器，这里开启了
  bool enable_look_ahead_back_control_ = false;

  // for compute the differential valute to estimate acceleration/lon_jerk
  double previous_lateral_acceleration_ = 0.0; // 上一时刻的横向加速度，主要为了差分计算横向加加速度

  double previous_heading_rate_ = 0.0;
  double previous_ref_heading_rate_ = 0.0;

  double previous_heading_acceleration_ = 0.0;
  double previous_ref_heading_acceleration_ = 0.0;

  // for logging purpose  声明文件流对象，用于存储横向调试日志信息
  std::ofstream steer_log_file_;

  const std::string name_;

  double query_relative_time_;

  double pre_steer_angle_ = 0.0;

  double pre_steering_position_ = 0.0;

  double minimum_speed_protection_ = 0.1; // 最小速度保护，车辆状态方程系数矩阵A中有好几项分母中含有v的，若v为0或者过小时会引发冲击或者错误，因此在更新系数矩阵时v小于保护速度就用保护速度代入

  double current_trajectory_timestamp_ = -1.0;

  double init_vehicle_x_ = 0.0;     // 导航模式用的，默认关闭导航模式，略过

  double init_vehicle_y_ = 0.0;

  double init_vehicle_heading_ = 0.0;

  double low_speed_bound_ = 0.0;    // 定义低高速的切换临界点，低速的边界，有些控制参数采用低速高速两套，低速边界默认设置为3m/s

  double low_speed_window_ = 0.0;   // 低速窗口，主要是为了在高低速参数切换时防止过于生硬，又在这个窗口范围内进行线性插值

  double driving_orientation_ = 0.0;

  std::shared_ptr<DependencyInjector> injector_;
};

// 1.2 当前类声明为插件
CYBER_PLUGIN_MANAGER_REGISTER_PLUGIN(apollo::control::LatController,
                                     ControlTask)

}  // namespace control
}  // namespace apollo
